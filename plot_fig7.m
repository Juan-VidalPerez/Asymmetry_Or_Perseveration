function plot_fig7(varargin)
% Generates plots for Figure 7, showing behavioral signatures generated by
% simulating models with varying levels of confirmation bias or perseveration.
%
% This function creates three figures:
% 1. Figure 7a (CB): Learning curves for CB parameter sweep.
% 2. Figure 7a (PERS): Learning curves for PERS parameter sweep.
% 3. Figure 7b: Interaction term coefficient from history analysis for
%    'Katahira' and 'Classic' tasks.
%
% USAGE:
%   plot_fig7(100);       % Use 100 simulations for Fig 7a, 100 datasets for Fig 7b
%   plot_fig7(50000, 1000);  % Use 50000 for Fig 7a, 1000 datasets for Fig 7b (as in paper)
%
% INPUTS:
%   varargin{1} (n_sims_a) - Sims per parameter value for Figure 7a plots.
%   varargin{2} (n_sims_b) - (Optional) Number of datasets (each with 20 agents)
%                            to simulate for Figure 7b plot.
%
% REQUIREMENTS:
%   The function 'simulate_signatures.m' and the file 'MAP_fits.mat'
%   must be in the MATLAB path.

%% 1. Setup & Data Loading
close all;
fprintf('--- Generating Figure 7: Loading base parameters from MAP_fits.mat ---\n');

% Handle flexible n_sims input
if nargin == 0
    error('Please provide the number of simulations, e.g., plot_fig7(100).');
elseif nargin == 1
    n_sims_a = varargin{1};
    n_sims_b = varargin{1}; % Number of datasets for Fig 7b
else
    n_sims_a = varargin{1};
    n_sims_b = varargin{2}; % Number of datasets for Fig 7b
end
n_agents_per_dataset_b = 20; % Fixed number of agents per dataset in Fig 7b

try
    map_data = load('data/MAP_fits.mat');
catch ME
    error('Could not load data. Ensure "MAP_fits.mat" is in the MATLAB path. Details: %s', ME.message);
end

% --- Extract average parameters from Experiment P2 (index 4) ---
avg_params_cb_p2 = mean(map_data.parameters_CB{4}, 1);
base_beta_cb = avg_params_cb_p2(1);
base_mean_alpha_cb = 0.4; % Fixed as per instructions

avg_params_psl_p2 = mean(map_data.parameters_PSL{4}, 1);
base_beta_psl = avg_params_psl_p2(1);
base_alpha_psl = avg_params_psl_p2(2);
base_tau_psl = avg_params_psl_p2(3);

% --- Simulation & Parameter Configurations ---
sim_config = struct(...
    'CB', struct(...
        'base_params', [base_beta_cb, base_mean_alpha_cb], ...
        'values', -0.6:0.1:0.6, ...
        'param_label', '\alpha_c - \alpha_d', ...
        'model_idx', 1, ...
        'color_map_func', @(n) colormap(slanCM('berlin', n)) ...
    ), ...
    'PERS', struct(...
        'base_params', [base_beta_psl, base_alpha_psl, base_tau_psl], ...
        'values', -3:0.5:3, ...
        'param_label', '\phi', ...
        'model_idx', 2, ...
        'color_map_func', @(n) colormap(slanCM('vanimo', n)) ...
    ) ...
);

param_types = {'CB', 'PERS'};

% --- Experiment Configurations ---
experiments_lc = {'Stable','Reversal','Risk'};
experiments_hist = {'Katahira', 'Classic'}; % ** UPDATED: Add Classic Task **
history_labels = {'Intercept', 'R(t)', 'R(t-1)', 'R(t) * R(t-1)'};

% --- Plotting Configurations ---
marker = 'o'; % Use circles for history plot

%% 2. Plot Learning Curves (Separate Figures for CB and PERS - Figure 7a)
fprintf('--- Plotting Figure 7a (Learning Curves) ---\n');

for type_idx = 1:length(param_types)
    current_type = param_types{type_idx};
    cfg = sim_config.(current_type);
    
    fig_lc = figure('Position', [100 + (type_idx-1)*450, 100, 400, 800]);
    sgtitle(['Figure 7a (' current_type ')'], 'FontSize', 16, 'FontWeight', 'bold');
    colors = cfg.color_map_func(length(cfg.values));

    for exp_idx = 1:length(experiments_lc)
        current_experiment = experiments_lc{exp_idx};
        subplot(3, 1, exp_idx);
        hold on;
        
        n_trials_plot = NaN;
        for val_idx = 1:length(cfg.values)
            current_value = cfg.values(val_idx);

            if strcmp(current_type, 'CB')
                beta_sim = cfg.base_params(1);
                mean_alpha = cfg.base_params(2);
                lr1 = mean_alpha + current_value / 2; lr2 = mean_alpha - current_value / 2;
                lr1 = max(0, min(1, lr1)); lr2 = max(0, min(1, lr2));
                sim_params = repmat([beta_sim, lr1, lr2], [n_sims_a, 1]);
            else % PERS
                sim_params = repmat([cfg.base_params(1:3), current_value], [n_sims_a, 1]);
            end

            [sim_data] = simulate_signatures(sim_params, cfg.model_idx, current_experiment);
            
            n_trials_exp = length(sim_data{2}{1});
            n_trials_plot = n_trials_exp;
            choice_data = NaN(n_sims_a, n_trials_exp);
            for ss = 1:n_sims_a
                 choices = sim_data{2}{ss};
                 if strcmpi(current_experiment, 'Stable')
                     preferred_choice = mode(choices);
                     choice_data(ss, :) = (choices == preferred_choice);
                 else
                     choice_data(ss, :) = (choices == 2);
                 end
            end
            mean_choice_rate_per_trial = mean(choice_data, 1);
            x_trials = 1:n_trials_exp;

            if abs(current_value) < 1e-6
                plot(x_trials, mean_choice_rate_per_trial, '-.', 'LineWidth', 2.5, 'Color', colors(val_idx, :));
            else
                plot(x_trials, mean_choice_rate_per_trial, 'LineWidth', 2, 'Color', colors(val_idx, :));
            end
        end

        plot(x_trials, 0.5 * ones(size(x_trials)), '-', 'LineWidth', 1, 'Color', [0.5 0.5 0.5]);
        xlim([min(x_trials), n_trials_plot]);
        
        if exp_idx == 1
            ylabel('Preferred choice rate'); ylim([0.45, 1]); title('Stable');
        elseif exp_idx == 2
            plot([13 13], [0 1], 'k--', 'LineWidth', 1);
            ylabel('"A" choice rate'); title('Reversal'); ylim([0, 1]);
        elseif exp_idx == 3
            ylabel('"Risky" choice rate'); ylim([0.2, 0.8]); title('Risk');
            xlabel('Trial');
        end
    end
    
    ax_top = subplot(3, 1, 1);
    colormap(ax_top, colors);
    hcb = colorbar(ax_top, 'Location', 'northoutside');
    if strcmp(current_type, 'CB')
        ylabel(hcb, ['$' cfg.param_label '$'], 'Interpreter', 'latex');
    else % PERS
        ylabel(hcb, ['$' cfg.param_label '$'], 'Interpreter', 'latex');
    end
    clim(ax_top, [min(cfg.values), max(cfg.values)]);
    
end % End loop over parameter types (CB/PERS)


%% 3. Plot History Interaction Coefficient (Figure 7b)
fprintf('--- Plotting Figure 7b (Regression Analysis) ---\n');
fig_hist = figure('Position', [950, 100, 800, 700]); % Increased height for 2 rows
sgtitle('Figure 7b', 'FontSize', 16, 'FontWeight', 'bold');

interaction_coef_idx = 4; % Index of the R(t)*R(t-1) interaction term

% Loop through experiment types (Katahira, Classic)
for hist_exp_idx = 1:length(experiments_hist)
    current_hist_experiment = experiments_hist{hist_exp_idx};
    
    % Loop through parameter types (CB, PERS)
    for type_idx = 1:length(param_types)
        current_type = param_types{type_idx};
        cfg = sim_config.(current_type);
        % Get the specific colormap for this figure/subplot
        colors = cfg.color_map_func(length(cfg.values));
        
        % ** UPDATED subplot indexing for 2x2 layout **
        subplot_idx = (hist_exp_idx - 1) * 2 + type_idx;
        ax_hist = subplot(2, 2, subplot_idx); % Define axes for colormap
        hold on;
        
        % Store mean and sem across datasets for each value
        mean_coefs_across_datasets = NaN(length(cfg.values), 4);
        sem_coefs_across_datasets = NaN(length(cfg.values), 4);
        
        for val_idx = 1:length(cfg.values)
            current_value = cfg.values(val_idx);
            
            % Store coefficients from each dataset repetition
            coefs_from_datasets = NaN(n_sims_b, 4);
            
            for sim_idx = 1:n_sims_b % Loop over number of datasets
                
                % --- Construct parameter set for 20 agents ---
                if strcmp(current_type, 'CB')
                    beta_sim = cfg.base_params(1);
                    mean_alpha = cfg.base_params(2);
                    lr1 = mean_alpha + current_value / 2; lr2 = mean_alpha - current_value / 2;
                    lr1 = max(0, min(1, lr1)); lr2 = max(0, min(1, lr2));
                    sim_params = repmat([beta_sim, lr1, lr2], [n_agents_per_dataset_b, 1]);
                else % PERS
                    sim_params = repmat([cfg.base_params(1:3), current_value], [n_agents_per_dataset_b, 1]);
                end
                
                % --- Run simulation for this dataset ---
                [sim_data] = simulate_signatures(sim_params, cfg.model_idx, current_hist_experiment); % ** Use current_hist_experiment **
                
                % --- Perform logistic regression on this dataset ---
                [coefs, ~, ~] = PB_mem_Rt_Rprev(sim_data); % Nested function call
                coefs_from_datasets(sim_idx, :) = coefs';
                
            end % End loop over datasets (sim_idx)
            
            % --- Calculate mean and SEM across datasets ---
            mean_coefs_across_datasets(val_idx, :) = mean(coefs_from_datasets, 1);
            sem_coefs_across_datasets(val_idx, :) = std(coefs_from_datasets, 0, 1) / sqrt(n_sims_b);
            
            % --- Plot interaction coefficient point for this value ---
            errorbar(current_value, mean_coefs_across_datasets(val_idx, interaction_coef_idx), sem_coefs_across_datasets(val_idx, interaction_coef_idx), ...
                     'Color', colors(val_idx, :), 'LineWidth', 1.25, 'CapSize', 0);
            plot(current_value, mean_coefs_across_datasets(val_idx, interaction_coef_idx), marker, 'Color', colors(val_idx, :), ...
                 'LineWidth', 1.25, 'MarkerSize', 8, 'MarkerFaceColor', colors(val_idx, :), ...
                 'MarkerEdgeColor', 'black');
                 
        end % End loop over values
        
        % --- Finalize Subplot ---
        plot(cfg.values([1, end]), [0, 0], '-', 'LineWidth', 1, 'Color', [0.5 0.5 0.5]);
        xlim([min(cfg.values), max(cfg.values)]);
        % ** UPDATED Title to include experiment and type **
        title([current_hist_experiment ' (' current_type ')']);
        ylabel(history_labels{interaction_coef_idx});
        
        % Only add x-label to bottom plots
        if hist_exp_idx == length(experiments_hist)
            xlabel(cfg.param_label);
        else
            xticklabels({}); % Remove x-ticks for top row
        end
        

    end % End loop over parameter types (CB/PERS)
end % End loop over history experiments (Katahira/Classic)

end % End of main function plot_fig7

%% -------------------- Nested Function: Calculate Regression Signature from Katahira --------------------
function [coefs, p, sem] = PB_mem_Rt_Rprev(data)
R_now = []; R_prev = []; STAY = []; OPPORTUNITIES = []; SS = [];
for ss = 1:length(data{1})
    cho = data{2}{ss};
    out = (data{3}{ss} + 1) / 2;
    if length(cho) < 3, continue; end
    stay_tplus1 = double(cho(2:end-1) == cho(3:end));
    r_t = out(2:end-1);
    r_t_minus_1 = out(1:end-2);
    choice_t_eq_t_minus_1 = (cho(1:end-2) == cho(2:end-1));
    stay_tplus1 = stay_tplus1(choice_t_eq_t_minus_1);
    r_t = r_t(choice_t_eq_t_minus_1);
    r_t_minus_1 = r_t_minus_1(choice_t_eq_t_minus_1);
    for ii = 0:1
        for jj = 0:1
            condition_met = (r_t == ii & r_t_minus_1 == jj);
            STAY = [STAY, sum(stay_tplus1(condition_met))];
            OPPORTUNITIES = [OPPORTUNITIES, sum(condition_met)];
            R_now = [R_now, ii];
            R_prev = [R_prev, jj];
            SS = [SS, ss];
        end
    end
end
my_table = table(STAY', R_now', R_prev', SS', 'VariableNames', {'STAY', 'R_now', 'R_prev', 'SS'});
valid_indices = (OPPORTUNITIES > 0);
if ~any(valid_indices)
    warning('No valid opportunities found for GLME analysis.');
    coefs = NaN(4, 1); p = NaN(4, 1); sem = NaN(4, 1);
    return;
end
my_model = 'STAY ~ 1 + R_now * R_prev';
try
    mdl = fitglme(my_table(valid_indices,:), my_model, ...
                  'Distribution', 'Binomial', 'CheckHessian', true, ...
                  'FitMethod', 'Laplace', ...
                  'BinomialSize', OPPORTUNITIES(valid_indices)');
    coefs = double(mdl.Coefficients.Estimate);
    p     = double(mdl.Coefficients.pValue);
    sem   = double(mdl.Coefficients.SE);
    if numel(coefs) < 4
        coefs_full = NaN(4,1); p_full = NaN(4,1); sem_full = NaN(4,1);
        coefs_full(1:numel(coefs)) = coefs; p_full(1:numel(p)) = p; sem_full(1:numel(sem)) = sem;
        coefs = coefs_full; p = p_full; sem = sem_full;
    end
catch ME
    warning('GLME fitting failed: %s', ME.message);
    coefs = NaN(4, 1); p = NaN(4, 1); sem = NaN(4, 1);
end
end % End of nested function PB_mem_Rt_Rprev